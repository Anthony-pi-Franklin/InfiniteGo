<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RT-Sand MVP</title>
    <style>
      body {
        margin: 0;
        font-family: Arial, sans-serif;
        display: flex;
        height: 100vh;
      }
      #sidebar {
        width: 240px;
        background: #10141a;
        color: #eef1f5;
        padding: 16px;
        box-sizing: border-box;
      }
      #canvas-container {
        flex: 1;
        position: relative;
        background: #0b0f14;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: #0b0f14;
      }
      .log {
        height: 120px;
        overflow-y: auto;
        background: #0f1722;
        padding: 8px;
        font-size: 12px;
        border-radius: 4px;
        margin-top: 12px;
      }
      #minimap {
        display: block;
        width: 200px;
        height: 200px;
        background: #0f1722;
        border: 2px solid #374151;
        border-radius: 4px;
        margin-top: 12px;
      }
      label {
        display: block;
        margin-bottom: 8px;
      }
      button {
        padding: 8px 12px;
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      button:disabled {
        background: #475569;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <div id="sidebar">
      <h3>RT-Sand MVP</h3>
      <label>
        Color
        <select id="color">
          <option value="0">Black</option>
          <option value="1">White</option>
        </select>
      </label>
      <label>
        Placement Mode
        <select id="placement-mode">
          <option value="intersection">Intersection (交叉点)</option>
          <option value="cell">Cell Center (格子内)</option>
        </select>
      </label>
      <label>
        Minimap Scale
        <input type="range" id="scale" min="1" max="10" value="3" />
      </label>
      <button id="reset">Reset view</button>
      <p id="status">Connecting…</p>
      <canvas id="minimap" width="200" height="200"></canvas>
      <div class="log" id="log"></div>
    </div>
    <div id="canvas-container">
      <canvas id="board"></canvas>
    </div>
    <script>
      const canvas = document.getElementById("board");
      const ctx = canvas.getContext("2d");
      const minimap = document.getElementById("minimap");
      const minimapCtx = minimap.getContext("2d");
      const logEl = document.getElementById("log");
      const statusEl = document.getElementById("status");
      const colorSel = document.getElementById("color");
      const scaleInput = document.getElementById("scale");
      const placementMode = document.getElementById("placement-mode");
      const resetBtn = document.getElementById("reset");

      let scale = 24;
      let minimapScale = parseInt(scaleInput.value, 10);
      let pan = { x: 0, y: 0 };
      let dragging = false;
      let last = { x: 0, y: 0 };
      let seq = 0n;
      let edgeScrollActive = false;
      let edgeScrollInterval = null;
      let minimapDragging = false;
      let minimapDragStart = { x: 0, y: 0 };

      const stones = new Map(); // key => `${x},${y}` ; value {x:bigint,y:bigint,color:number}
      let ws;

      function log(msg) {
        const time = new Date().toLocaleTimeString();
        logEl.innerHTML = `<div>[${time}] ${msg}</div>` + logEl.innerHTML;
      }

      function resize() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        draw();
      }
      window.addEventListener("resize", resize);
      resize();

      function boardToScreen(x, y) {
        return {
          x: Number(x) * scale + canvas.width / 2 + pan.x,
          y: Number(-y) * scale + canvas.height / 2 + pan.y,
        };
      }

      function screenToBoard(px, py) {
        const mode = placementMode.value;
        const offset = mode === "cell" ? scale / 2 : 0;
        const bx = Math.round((px - canvas.width / 2 - pan.x - offset) / scale);
        const by = Math.round(-(py - canvas.height / 2 - pan.y - offset) / scale);
        return { x: BigInt(bx), y: BigInt(by) };
      }

      function drawGrid() {
        ctx.strokeStyle = "#1f2937";
        ctx.lineWidth = 1;
        const step = scale;
        
        // Calculate the board origin in screen coordinates
        const originX = canvas.width / 2 + pan.x;
        const originY = canvas.height / 2 + pan.y;
        
        // Find the first grid line to the left/top of the viewport
        const startX = originX % step;
        const startY = originY % step;
        
        for (let x = startX; x < canvas.width; x += step) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let y = startY; y < canvas.height; y += step) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
      }

      function drawStones() {
        const mode = placementMode.value;
        const offset = mode === "cell" ? scale / 2 : 0;
        for (const [, stone] of stones) {
          const { x, y } = boardToScreen(stone.x, stone.y);
          ctx.beginPath();
          ctx.fillStyle = stone.color === 0 ? "#0f172a" : "#f9fafb";
          ctx.strokeStyle = "#e5e7eb";
          ctx.arc(x + offset, y + offset, scale * 0.45, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawStones();
        ctx.fillStyle = "#9ca3af";
        ctx.fillText(`Seq: ${seq.toString()}`, 12, 20);
        drawMinimap();
      }

      // Edge scrolling logic
      function handleEdgeScroll(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const edgeThreshold = 100;
        const maxSpeed = 20;

        let dx = 0, dy = 0;

        if (x < edgeThreshold) {
          dx = maxSpeed * (1 - x / edgeThreshold);
        } else if (x > canvas.width - edgeThreshold) {
          dx = -maxSpeed * (1 - (canvas.width - x) / edgeThreshold);
        }

        if (y < edgeThreshold) {
          dy = maxSpeed * (1 - y / edgeThreshold);
        } else if (y > canvas.height - edgeThreshold) {
          dy = -maxSpeed * (1 - (canvas.height - y) / edgeThreshold);
        }

        if (dx !== 0 || dy !== 0) {
          if (!edgeScrollActive) {
            edgeScrollActive = true;
            edgeScrollInterval = setInterval(() => {
              pan.x += dx;
              pan.y += dy;
              draw();
            }, 16);
          }
        } else if (edgeScrollActive) {
          clearInterval(edgeScrollInterval);
          edgeScrollActive = false;
        }
      }

      canvas.addEventListener("mousedown", (e) => {
        dragging = true;
        last = { x: e.clientX, y: e.clientY };
      });

      window.addEventListener("mouseup", () => (dragging = false));
      
      window.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const inCanvas = e.clientX >= rect.left && e.clientX <= rect.right &&
                         e.clientY >= rect.top && e.clientY <= rect.bottom;
        
        if (inCanvas) {
          handleEdgeScroll(e);
        } else if (edgeScrollActive) {
          clearInterval(edgeScrollInterval);
          edgeScrollActive = false;
        }

        if (!dragging) return;
        const dx = e.clientX - last.x;
        const dy = e.clientY - last.y;
        pan.x += dx;
        pan.y += dy;
        last = { x: e.clientX, y: e.clientY };
        draw();
      });

      canvas.addEventListener("click", (e) => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const board = screenToBoard(x, y);
        const payload = {
          x: board.x.toString(),
          y: board.y.toString(),
          color: parseInt(colorSel.value, 10),
        };
        ws.send(JSON.stringify(payload));
      });

      // Mouse wheel zoom
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const delta = -Math.sign(e.deltaY);
        const zoomFactor = 1.1;
        const oldScale = scale;
        scale = delta > 0 ? scale * zoomFactor : scale / zoomFactor;
        scale = Math.max(6, Math.min(80, scale));

        // Zoom toward mouse position
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const worldX = (mouseX - canvas.width / 2 - pan.x) / oldScale;
        const worldY = (mouseY - canvas.height / 2 - pan.y) / oldScale;
        pan.x = mouseX - canvas.width / 2 - worldX * scale;
        pan.y = mouseY - canvas.height / 2 - worldY * scale;

        draw();
      }, { passive: false });

      scaleInput.addEventListener("input", () => {
        minimapScale = parseInt(scaleInput.value, 10);
        draw();
      });

      placementMode.addEventListener("change", () => {
        draw();
      });

      resetBtn.addEventListener("click", () => {
        pan = { x: 0, y: 0 };
        scale = 24;
        minimapScale = 3;
        scaleInput.value = "3";
        draw();
      });

      function drawMinimap() {
        minimapCtx.clearRect(0, 0, minimap.width, minimap.height);
        minimapCtx.fillStyle = "#0b0f14";
        minimapCtx.fillRect(0, 0, minimap.width, minimap.height);

        if (stones.size === 0) return;

        // Calculate bounds of all stones
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        for (const [, stone] of stones) {
          const x = Number(stone.x);
          const y = Number(stone.y);
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }

        // Add padding
        const padding = 5;
        minX -= padding;
        maxX += padding;
        minY -= padding;
        maxY += padding;

        const rangeX = maxX - minX || 1;
        const rangeY = maxY - minY || 1;
        const scaleX = (minimap.width - 20) / rangeX;
        const scaleY = (minimap.height - 20) / rangeY;
        const mmScale = Math.min(scaleX, scaleY) * minimapScale / 3;

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        // Draw territory (influence areas) with color mixing
        const territoryMap = new Map();
        const influenceRadius = 3;

        for (const [, stone] of stones) {
          const x = Number(stone.x);
          const y = Number(stone.y);
          
          for (let dx = -influenceRadius; dx <= influenceRadius; dx++) {
            for (let dy = -influenceRadius; dy <= influenceRadius; dy++) {
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist > influenceRadius) continue;
              
              const key = `${x + dx},${y + dy}`;
              const influence = 1 - (dist / influenceRadius);
              
              if (!territoryMap.has(key)) {
                territoryMap.set(key, { 0: 0, 1: 0 });
              }
              territoryMap.get(key)[stone.color] += influence;
            }
          }
        }

        // Draw territory
        for (const [key, influences] of territoryMap) {
          const [tx, ty] = key.split(',').map(Number);
          const screenX = (tx - centerX) * mmScale + minimap.width / 2;
          const screenY = -(ty - centerY) * mmScale + minimap.height / 2;

          const total = influences[0] + influences[1];
          const blackRatio = influences[0] / total;
          
          let r, g, b, alpha;
          if (blackRatio > 0.6) {
            // Black territory
            r = 15; g = 23; b = 42;
            alpha = Math.min(0.8, (blackRatio - 0.5) * 2);
          } else if (blackRatio < 0.4) {
            // White territory
            r = 249; g = 250; b = 251;
            alpha = Math.min(0.8, (0.5 - blackRatio) * 2);
          } else {
            // Contested
            r = 100; g = 100; b = 100;
            alpha = 0.3;
          }

          minimapCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
          minimapCtx.fillRect(screenX - 1, screenY - 1, 2, 2);
        }

        // Draw stones
        for (const [, stone] of stones) {
          const x = Number(stone.x);
          const y = Number(stone.y);
          const screenX = (x - centerX) * mmScale + minimap.width / 2;
          const screenY = -(y - centerY) * mmScale + minimap.height / 2;

          minimapCtx.beginPath();
          minimapCtx.fillStyle = stone.color === 0 ? "#0f172a" : "#f9fafb";
          minimapCtx.arc(screenX, screenY, Math.max(1, mmScale * 0.4), 0, Math.PI * 2);
          minimapCtx.fill();
        }

        // Draw viewport indicator
        const viewCenterX = -pan.x / scale;
        const viewCenterY = pan.y / scale;
        const viewWidth = canvas.width / scale;
        const viewHeight = canvas.height / scale;
        
        const vx = (viewCenterX - centerX) * mmScale + minimap.width / 2;
        const vy = -(viewCenterY - centerY) * mmScale + minimap.height / 2;
        const vw = viewWidth * mmScale;
        const vh = viewHeight * mmScale;

        minimapCtx.strokeStyle = "#3b82f6";
        minimapCtx.lineWidth = 2;
        minimapCtx.strokeRect(vx - vw / 2, vy - vh / 2, vw, vh);
        
        // Store minimap transform for dragging
        minimap._centerX = centerX;
        minimap._centerY = centerY;
        minimap._mmScale = mmScale;
      }

      // Minimap drag handlers
      minimap.addEventListener("mousedown", (e) => {
        if (!minimap._mmScale) return;
        
        const rect = minimap.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        
        // Convert minimap click to world coordinates
        const worldX = (clickX - minimap.width / 2) / minimap._mmScale + minimap._centerX;
        const worldY = -((clickY - minimap.height / 2) / minimap._mmScale) + minimap._centerY;
        
        // Set this world position as the center of the main view
        pan.x = -worldX * scale;
        pan.y = worldY * scale;
        
        draw();
        
        minimapDragging = true;
        minimapDragStart = {
          x: clickX,
          y: clickY,
        };
      });

      window.addEventListener("mouseup", () => {
        minimapDragging = false;
      });

      minimap.addEventListener("mousemove", (e) => {
        if (!minimapDragging || !minimap._mmScale) return;
        
        const rect = minimap.getBoundingClientRect();
        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;
        
        // Convert current position to world coordinates
        const worldX = (currentX - minimap.width / 2) / minimap._mmScale + minimap._centerX;
        const worldY = -((currentY - minimap.height / 2) / minimap._mmScale) + minimap._centerY;
        
        // Set as center of main view
        pan.x = -worldX * scale;
        pan.y = worldY * scale;
        
        draw();
      });

      function applyDelta(delta) {
        seq = BigInt(delta.server_seq);
        for (const cell of delta.removed || []) {
          stones.delete(`${cell.x},${cell.y}`);
        }
        for (const cell of delta.added || []) {
          stones.set(`${cell.x},${cell.y}`, {
            x: BigInt(cell.x),
            y: BigInt(cell.y),
            color: Number(cell.color),
          });
        }
        draw();
      }

      function applyBoardState(state) {
        seq = BigInt(state.server_seq);
        stones.clear();
        for (const cell of state.cells || []) {
          stones.set(`${cell.x},${cell.y}`, {
            x: BigInt(cell.x),
            y: BigInt(cell.y),
            color: Number(cell.color),
          });
        }
        draw();
        log(`loaded ${state.cells?.length || 0} stones from server`);
      }

      function connect() {
        ws = new WebSocket(`ws://${location.host}/ws`);
        ws.onopen = () => {
          statusEl.textContent = "Connected";
          log("connected to server");
          // Request initial board state
          ws.send(JSON.stringify({ type: "get_state" }));
        };
        ws.onclose = () => {
          statusEl.textContent = "Disconnected";
          log("connection closed, retrying in 2s");
          setTimeout(connect, 2000);
        };
        ws.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            if (msg.type === "board_state" && msg.board_state) {
              applyBoardState(msg.board_state);
            } else if (msg.type === "delta_update" && msg.delta_update) {
              applyDelta(msg.delta_update);
            } else if (msg.type === "move_result" && msg.move_result) {
              const res = msg.move_result;
              if (!res.accepted) {
                log(`move rejected: ${res.reason || "unknown"}`);
              } else {
                log(`move accepted (seq ${res.server_seq})`);
              }
            }
          } catch (err) {
            console.error(err);
          }
        };
      }

      connect();
      draw();
    </script>
  </body>
</html>
