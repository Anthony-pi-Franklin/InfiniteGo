<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RT-Sand MVP</title>
    <style>
      :root {
        --bg: #0b0f14;
        --panel: #10141a;
        --panel-2: #0f1722;
        --text: #eef1f5;
        --muted: #9ca3af;
        --accent: #2563eb;
        --border: #374151;
      }
      body {
        margin: 0;
        font-family: Arial, sans-serif;
        background: var(--bg);
      }
      #app {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
      }
      #canvas-container {
        position: absolute;
        inset: 0;
        background: var(--bg);
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: var(--bg);
      }
      #sidebar-toggle {
        position: absolute;
        top: 16px;
        left: 16px;
        z-index: 10;
        padding: 8px 12px;
        background: var(--panel);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 6px;
        cursor: pointer;
      }
      #sidebar {
        position: absolute;
        top: 56px;
        left: 16px;
        width: 260px;
        max-height: calc(100vh - 72px);
        background: var(--panel);
        color: var(--text);
        padding: 16px;
        box-sizing: border-box;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.35);
        overflow-y: auto;
        transition: transform 0.2s ease, opacity 0.2s ease;
        z-index: 9;
      }
      #sidebar.collapsed {
        transform: translateX(-120%);
        opacity: 0.0;
        pointer-events: none;
      }
      .log {
        height: 120px;
        overflow-y: auto;
        background: var(--panel-2);
        padding: 8px;
        font-size: 12px;
        border-radius: 4px;
        margin-top: 12px;
      }
      #minimap {
        display: block;
        width: 200px;
        height: 200px;
        background: var(--panel-2);
        border: 2px solid var(--border);
        border-radius: 4px;
        margin-top: 12px;
      }
      #leaderboard {
        margin-top: 12px;
        padding: 8px;
        background: var(--panel-2);
        border-radius: 4px;
      }
      #leaderboard h4 {
        margin: 0 0 8px 0;
        color: var(--muted);
        font-size: 14px;
      }
      #stats {
        font-size: 12px;
        color: #e5e7eb;
      }
      #stats div {
        margin: 4px 0;
        display: flex;
        justify-content: space-between;
      }
      #stats .color-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 6px;
        border: 1px solid #e5e7eb;
      }
      label {
        display: block;
        margin-bottom: 8px;
      }
      .inline-controls {
        display: flex;
        gap: 8px;
      }
      .inline-controls label {
        flex: 1;
        margin: 0;
      }
      .inline-controls select {
        width: 100%;
      }
      button {
        padding: 8px 12px;
        background: var(--accent);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      button:disabled {
        background: #475569;
        cursor: not-allowed;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .row button {
        flex: 1;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <button id="sidebar-toggle">☰ Menu</button>
      <div id="sidebar" class="open">
        <h3 style="margin-top:0; margin-bottom:12px;">RT-Sand MVP</h3>
        <div class="inline-controls" style="margin-bottom:12px;">
          <label>
            Color
            <select id="color">
              <option value="0">Black</option>
              <option value="1">White</option>
            </select>
          </label>
          <label>
            Placement
            <select id="placement-mode">
              <option value="intersection">Intersection</option>
              <option value="cell">Cell Center</option>
            </select>
          </label>
        </div>
        <div class="row" style="margin-bottom:12px;">
          <button id="reset">Reset view</button>
          <button id="restart" style="background:#ef4444;">Restart</button>
        </div>
        <p id="status" style="margin: 4px 0 12px 0; color: var(--muted);">Connecting…</p>
        <div id="leaderboard">
          <h4>Leaderboard</h4>
          <div id="stats"></div>
        </div>
        <canvas id="minimap" width="200" height="200"></canvas>
        <div class="log" id="log"></div>
      </div>
      <div id="canvas-container">
        <canvas id="board"></canvas>
      </div>
    </div>
    <script>
      const canvas = document.getElementById("board");
      const ctx = canvas.getContext("2d");
      const minimap = document.getElementById("minimap");
      const minimapCtx = minimap.getContext("2d");
      const logEl = document.getElementById("log");
      const statusEl = document.getElementById("status");
      const colorSel = document.getElementById("color");
      const placementMode = document.getElementById("placement-mode");
      const resetBtn = document.getElementById("reset");
      const restartBtn = document.getElementById("restart");
      const sidebar = document.getElementById("sidebar");
      const sidebarToggle = document.getElementById("sidebar-toggle");

      let scale = 24;
      let minimapScale = 3;
      let pan = { x: 0, y: 0 };
      
      // Load saved view state
      try {
        const saved = localStorage.getItem('infinitego-view');
        if (saved) {
          const state = JSON.parse(saved);
          pan.x = state.pan?.x || 0;
          pan.y = state.pan?.y || 0;
          scale = state.scale || 24;
        }
      } catch (e) {
        console.warn('Failed to load saved view state:', e);
      }
      
      let dragging = false;
      let last = { x: 0, y: 0 };
      let seq = 0n;
      let edgeScrollActive = false;
      let edgeScrollInterval = null;
      let minimapDragging = false;
      let minimapDragStart = { x: 0, y: 0 };

      const stones = new Map(); // key => `${x},${y}` ; value {x:bigint,y:bigint,color:number}
      let ws;

      function log(msg) {
        const time = new Date().toLocaleTimeString();
        logEl.innerHTML = `<div>[${time}] ${msg}</div>` + logEl.innerHTML;
      }

      function resize() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        draw();
      }
      window.addEventListener("resize", resize);
      resize();

      function boardToScreen(x, y) {
        return {
          x: Number(x) * scale + canvas.width / 2 + pan.x,
          y: Number(-y) * scale + canvas.height / 2 + pan.y,
        };
      }

      function screenToBoard(px, py) {
        const mode = placementMode.value;
        const offset = mode === "cell" ? scale / 2 : 0;
        const bx = Math.round((px - canvas.width / 2 - pan.x - offset) / scale);
        const by = Math.round(-(py - canvas.height / 2 - pan.y - offset) / scale);
        return { x: BigInt(bx), y: BigInt(by) };
      }

      function drawGrid() {
        ctx.strokeStyle = "#1f2937";
        ctx.lineWidth = 1;
        const step = scale;
        
        // Calculate the board origin in screen coordinates
        const originX = canvas.width / 2 + pan.x;
        const originY = canvas.height / 2 + pan.y;
        
        // Find the first grid line to the left/top of the viewport
        const startX = originX % step;
        const startY = originY % step;
        
        for (let x = startX; x < canvas.width; x += step) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let y = startY; y < canvas.height; y += step) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
      }

      function drawStones() {
        const mode = placementMode.value;
        const offset = mode === "cell" ? scale / 2 : 0;
        for (const [, stone] of stones) {
          const { x, y } = boardToScreen(stone.x, stone.y);
          ctx.beginPath();
          ctx.fillStyle = stone.color === 0 ? "#0f172a" : "#f9fafb";
          ctx.strokeStyle = "#e5e7eb";
          ctx.arc(x + offset, y + offset, scale * 0.45, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawStones();
        ctx.fillStyle = "#9ca3af";
        ctx.fillText(`Seq: ${seq.toString()}`, 12, 20);
        drawMinimap();
        updateLeaderboard();
        saveViewState();
      }

      function saveViewState() {
        try {
          localStorage.setItem('infinitego-view', JSON.stringify({
            pan: { x: pan.x, y: pan.y },
            scale: scale,
          }));
        } catch (e) {
          console.warn('Failed to save view state:', e);
        }
      }

      function updateLeaderboard() {
        const stats = {};
        for (const [, stone] of stones) {
          const colorName = stone.color === 0 ? 'Black' : 'White';
          stats[colorName] = (stats[colorName] || 0) + 1;
        }
        
        const statsEl = document.getElementById('stats');
        const entries = Object.entries(stats).sort((a, b) => b[1] - a[1]);
        
        if (entries.length === 0) {
          statsEl.innerHTML = '<div style="color: #6b7280;">No stones yet</div>';
        } else {
          statsEl.innerHTML = entries.map(([color, count]) => {
            const bgColor = color === 'Black' ? '#0f172a' : '#f9fafb';
            return `<div>
              <span><span class="color-indicator" style="background: ${bgColor};"></span>${color}</span>
              <span><strong>${count}</strong></span>
            </div>`;
          }).join('');
        }
      }

      // Edge scrolling logic
      function handleEdgeScroll(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const edgeThreshold = 100;
        const maxSpeed = 20;

        let dx = 0, dy = 0;

        if (x < edgeThreshold) {
          dx = maxSpeed * (1 - x / edgeThreshold);
        } else if (x > canvas.width - edgeThreshold) {
          dx = -maxSpeed * (1 - (canvas.width - x) / edgeThreshold);
        }

        if (y < edgeThreshold) {
          dy = maxSpeed * (1 - y / edgeThreshold);
        } else if (y > canvas.height - edgeThreshold) {
          dy = -maxSpeed * (1 - (canvas.height - y) / edgeThreshold);
        }

        if (dx !== 0 || dy !== 0) {
          if (!edgeScrollActive) {
            edgeScrollActive = true;
            edgeScrollInterval = setInterval(() => {
              pan.x += dx;
              pan.y += dy;
              draw();
            }, 16);
          }
        } else if (edgeScrollActive) {
          clearInterval(edgeScrollInterval);
          edgeScrollActive = false;
        }
      }

      canvas.addEventListener("mousedown", (e) => {
        dragging = true;
        last = { x: e.clientX, y: e.clientY };
      });

      window.addEventListener("mouseup", () => (dragging = false));
      
      window.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const inCanvas = e.clientX >= rect.left && e.clientX <= rect.right &&
                         e.clientY >= rect.top && e.clientY <= rect.bottom;
        
        if (inCanvas) {
          handleEdgeScroll(e);
        } else if (edgeScrollActive) {
          clearInterval(edgeScrollInterval);
          edgeScrollActive = false;
        }

        if (!dragging) return;
        const dx = e.clientX - last.x;
        const dy = e.clientY - last.y;
        pan.x += dx;
        pan.y += dy;
        last = { x: e.clientX, y: e.clientY };
        draw();
      });

      canvas.addEventListener("click", (e) => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const board = screenToBoard(x, y);
        const payload = {
          x: board.x.toString(),
          y: board.y.toString(),
          color: parseInt(colorSel.value, 10),
        };
        ws.send(JSON.stringify(payload));
      });

      // Mouse wheel zoom
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const delta = -Math.sign(e.deltaY);
        const zoomFactor = 1.1;
        const oldScale = scale;
        scale = delta > 0 ? scale * zoomFactor : scale / zoomFactor;
        scale = Math.max(6, Math.min(80, scale));

        // Zoom toward mouse position
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const worldX = (mouseX - canvas.width / 2 - pan.x) / oldScale;
        const worldY = (mouseY - canvas.height / 2 - pan.y) / oldScale;
        pan.x = mouseX - canvas.width / 2 - worldX * scale;
        pan.y = mouseY - canvas.height / 2 - worldY * scale;

        draw();
      }, { passive: false });

      // Minimap zoom via wheel / trackpad
      minimap.addEventListener("wheel", (e) => {
        e.preventDefault();
        const delta = -Math.sign(e.deltaY);
        const factor = delta > 0 ? 1.1 : 1 / 1.1;
        minimapScale = Math.max(1, Math.min(10, minimapScale * factor));
        draw();
      }, { passive: false });

      placementMode.addEventListener("change", () => {
        draw();
      });

      resetBtn.addEventListener("click", () => {
        pan = { x: 0, y: 0 };
        scale = 24;
        minimapScale = 3;
        draw();
      });

      restartBtn.addEventListener("click", () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "restart" }));
        }
      });

      sidebarToggle.addEventListener("click", () => {
        const collapsed = sidebar.classList.toggle("collapsed");
        sidebarToggle.textContent = collapsed ? "☰ Menu" : "✕ Hide";
      });

      function drawMinimap() {
        minimapCtx.clearRect(0, 0, minimap.width, minimap.height);
        minimapCtx.fillStyle = "#0b0f14";
        minimapCtx.fillRect(0, 0, minimap.width, minimap.height);

        if (stones.size === 0) return;

        // Calculate bounds of all stones
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        for (const [, stone] of stones) {
          const x = Number(stone.x);
          const y = Number(stone.y);
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }

        // Add padding
        const padding = 5;
        minX -= padding;
        maxX += padding;
        minY -= padding;
        maxY += padding;

        const rangeX = maxX - minX || 1;
        const rangeY = maxY - minY || 1;
        const scaleX = (minimap.width - 20) / rangeX;
        const scaleY = (minimap.height - 20) / rangeY;
        const mmScale = Math.min(scaleX, scaleY) * minimapScale / 3;

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        // Draw stones directly
        for (const [, stone] of stones) {
          const x = Number(stone.x);
          const y = Number(stone.y);
          const screenX = (x - centerX) * mmScale + minimap.width / 2;
          const screenY = -(y - centerY) * mmScale + minimap.height / 2;

          minimapCtx.beginPath();
          minimapCtx.fillStyle = stone.color === 0 ? "#0f172a" : "#f9fafb";
          minimapCtx.strokeStyle = stone.color === 0 ? "#4b5563" : "#d1d5db";
          minimapCtx.lineWidth = 0.5;
          minimapCtx.arc(screenX, screenY, Math.max(1.5, mmScale * 0.4), 0, Math.PI * 2);
          minimapCtx.fill();
          minimapCtx.stroke();
        }

        // Draw viewport indicator
        const viewCenterX = -pan.x / scale;
        const viewCenterY = pan.y / scale;
        const viewWidth = canvas.width / scale;
        const viewHeight = canvas.height / scale;
        
        const vx = (viewCenterX - centerX) * mmScale + minimap.width / 2;
        const vy = -(viewCenterY - centerY) * mmScale + minimap.height / 2;
        const vw = viewWidth * mmScale;
        const vh = viewHeight * mmScale;

        minimapCtx.strokeStyle = "#3b82f6";
        minimapCtx.lineWidth = 2;
        minimapCtx.strokeRect(vx - vw / 2, vy - vh / 2, vw, vh);
        
        // Store minimap transform for dragging
        minimap._centerX = centerX;
        minimap._centerY = centerY;
        minimap._mmScale = mmScale;
      }

      // Minimap drag handlers
      minimap.addEventListener("mousedown", (e) => {
        if (!minimap._mmScale) return;
        
        const rect = minimap.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        
        // Convert minimap click to world coordinates
        const worldX = (clickX - minimap.width / 2) / minimap._mmScale + minimap._centerX;
        const worldY = -((clickY - minimap.height / 2) / minimap._mmScale) + minimap._centerY;
        
        // Set this world position as the center of the main view
        pan.x = -worldX * scale;
        pan.y = worldY * scale;
        
        draw();
        
        minimapDragging = true;
        minimapDragStart = {
          x: clickX,
          y: clickY,
        };
      });

      window.addEventListener("mouseup", () => {
        minimapDragging = false;
      });

      minimap.addEventListener("mousemove", (e) => {
        if (!minimapDragging || !minimap._mmScale) return;
        
        const rect = minimap.getBoundingClientRect();
        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;
        
        // Convert current position to world coordinates
        const worldX = (currentX - minimap.width / 2) / minimap._mmScale + minimap._centerX;
        const worldY = -((currentY - minimap.height / 2) / minimap._mmScale) + minimap._centerY;
        
        // Set as center of main view
        pan.x = -worldX * scale;
        pan.y = worldY * scale;
        
        draw();
      });

      function applyDelta(delta) {
        seq = BigInt(delta.server_seq);
        for (const cell of delta.removed || []) {
          stones.delete(`${cell.x},${cell.y}`);
        }
        for (const cell of delta.added || []) {
          stones.set(`${cell.x},${cell.y}`, {
            x: BigInt(cell.x),
            y: BigInt(cell.y),
            color: Number(cell.color),
          });
        }
        draw();
      }

      function applyBoardState(state) {
        seq = BigInt(state.server_seq);
        stones.clear();
        for (const cell of state.cells || []) {
          stones.set(`${cell.x},${cell.y}`, {
            x: BigInt(cell.x),
            y: BigInt(cell.y),
            color: Number(cell.color),
          });
        }
        draw();
        log(`loaded ${state.cells?.length || 0} stones from server`);
      }

      function connect() {
        ws = new WebSocket(`ws://${location.host}/ws`);
        ws.onopen = () => {
          statusEl.textContent = "Connected";
          log("connected to server");
          // Request initial board state
          ws.send(JSON.stringify({ type: "get_state" }));
        };
        ws.onclose = () => {
          statusEl.textContent = "Disconnected";
          log("connection closed, retrying in 2s");
          setTimeout(connect, 2000);
        };
        ws.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            if (msg.type === "board_state" && msg.board_state) {
              applyBoardState(msg.board_state);
            } else if (msg.type === "delta_update" && msg.delta_update) {
              applyDelta(msg.delta_update);
            } else if (msg.type === "move_result" && msg.move_result) {
              const res = msg.move_result;
              if (!res.accepted) {
                log(`move rejected: ${res.reason || "unknown"}`);
              } else {
                log(`move accepted (seq ${res.server_seq})`);
              }
            }
          } catch (err) {
            console.error(err);
          }
        };
      }

      connect();
      draw();
    </script>
  </body>
</html>
